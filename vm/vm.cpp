#include "vm.h"
#include "vm_impl.h"

#include <interrupts.h>

#include <exceptions.h>
#include <opcodes.h>
#include <hal.h>
#include <types.h>
#include <util.h>

#include <algorithm>
#include <algorithm>
#include <memory>
#include <sstream>
#include <iomanip>

using namespace primal;


vm::vm() : impl(new vm_impl)
{
}

bool vm::run(const std::vector<uint8_t> &app)
{
    return impl->run(app, this);
}

word_t &vm::ip()      {return impl->ip();}

word_t vm::ip() const {return impl->ip();}

void vm::set_mem(word_t address, word_t new_value)
{
    impl->set_mem(address, new_value);
}

word_t vm::get_mem(word_t address)
{
    return impl->get_mem(address);
}

void vm::set_mem_byte(word_t address, uint8_t b)
{
    impl->set_mem_byte(address, b);
}

uint8_t vm::get_mem_byte(word_t address)
{
    return impl->get_mem_byte(address);
}

std::shared_ptr<vm> vm::create()
{
    // these functions are autogenerated by cmake in their own files
    register_opcodes();
    register_interrupts();

    return std::make_shared<vm>();
}


valued *vm::fetch()
{
    return impl->fetch();
}

reg &vm::r(uint8_t i)             { return impl->m_r[i];}
const reg &vm::r(uint8_t i) const { return impl->m_r[i];}

bool vm::copy(word_t dest, word_t src, word_t cnt)
{
    return impl->copy(dest, src, cnt);
}

bool vm::push(const valued *v)
{
    return impl->push(v);
}

bool vm::push(const word_t v)
{
    return impl->push(v);
}

word_t vm::pop()
{
    return impl->pop();
}


word_t vm::flag() const {return impl->flag();}

void vm::set_flag(word_t v)
{
    impl->m_r[253].set_value( v );
}

bool vm::jump(word_t v)
{
    impl->m_ip = v;
    return impl->m_ip < VM_MEM_SEGMENT_SIZE + impl->app_size;
}

bool vm::interrupt(word_t i)
{
    std::function<bool(vm*)> fun;
    if(impl->interrupts.count(i) > 0)
    {
        return impl->interrupts[i].runner(this);
    }
    else
    {
        panic(std::string(("Unimplemented interrupt called: ") + std::to_string(i)).c_str());
    }
}

bool vm::address_is_valid(word_t addr)
{
    return addr <= impl->app_size + VM_MEM_SEGMENT_SIZE && addr >= 0;
}

void vm::debug(opcodes::opcode &&o, OpcodeDebugState ods)
{
    if(m_debug)
    {
        static size_t last_debugged_ip = 0 ;
        if(ods == OpcodeDebugState::VM_DEBUG_BEFORE)
        {
            size_t local_ip = impl->ip();
            last_debugged_ip = local_ip;

            std::cout << "->" << std::setw(5) << local_ip << ":";

            std::cout << o.name() << " (" << o.paramcount() << ") ";

            for(size_t i=0; i<o.paramcount(); i++)
            {
                impl->peek(local_ip);
            }

            if(o.bin() == primal::opcodes::POP().bin())
            {
                std::cout << " SP= ["<< impl->sp.value() <<"] ";
            }
            if(o.bin() == primal::opcodes::PUSH().bin())
            {
                std::cout << " SP= ["<< impl->sp.value() <<"] ";
            }

            std::cout << " =>> ";


        }

        if(ods == OpcodeDebugState::VM_DEBUG_AFTER)
        {
            size_t local_ip = last_debugged_ip;

            std::cout << "->" << std::setw(5) << local_ip << ":";

            std::cout << o.name() << " (" << o.paramcount() << ") ";

            for(size_t i=0; i<o.paramcount(); i++)
            {
                impl->peek(local_ip);
            }
            if(o.bin() == primal::opcodes::POP().bin())
            {
                std::cout << " SP= ["<< impl->sp.value() <<"] ";
            }
            if(o.bin() == primal::opcodes::PUSH().bin())
            {
                std::cout << " SP= ["<< impl->sp.value() <<"] ";
            }

            std::cout << std::endl;
        }

    }
}

std::shared_ptr<vm_impl> vm::get_impl() const
{
    return impl;
}

void vm::set_debug(bool newDebug)
{
    m_debug = newDebug;
    impl->set_debug(newDebug);
}


void vm::panic(const char* reason)
{
    impl->panic(reason);
}
