#include "vm.h"

#include <interrupts.h>

#include <exceptions.h>
#include <opcodes.h>
#include <hal.h>
#include <types.h>
#include <util.h>

#include <algorithm>
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <memory>
#include <cstring>
#include <sstream>

using namespace primal;

std::map<uint8_t, vm::executor> vm::opcode_runners;
std::map<uint8_t, vm::executor> vm::interrupts;

vm::vm() : sp(r(255))
{
    for(uint8_t i = 0; i<255; i++)
    {
        m_r[i].set_idx(i);
    }
}

vm::~vm()
{
    std::fill(ms.get(), ms.get() + VM_MEM_SEGMENT_SIZE + app_size, 0xFF);
}


bool vm::run(const std::vector<uint8_t> &app)
{
    // firstly set up the memory segment for this machine and initialize it to 0xFF
    app_size = static_cast<numeric_t>(app.size());
    ms = std::make_unique<uint8_t[]>(static_cast<size_t>(app_size + VM_MEM_SEGMENT_SIZE));
    std::fill(ms.get(), ms.get() + VM_MEM_SEGMENT_SIZE + app_size, 0x00);

    // then copy over the data from app to the end of the memory segment
    std::copy(app.begin(), app.end(), ms.get() + VM_MEM_SEGMENT_SIZE);

    // set the IP and SP to point to the correct location
    m_ip = VM_MEM_SEGMENT_SIZE + 16; // will grow upwards, will skip .P10 and the stringtable loc entry
    stack_offset = *reinterpret_cast<numeric_t*>(ms.get() + VM_MEM_SEGMENT_SIZE + 8);
    sp = stack_offset * num_t_size;   // will grow upwards

    // then start running it
    while(opcode_runners.count(ms[static_cast<size_t>(m_ip)]))
    {
        // read in an opcode
        uint8_t opc = ms[static_cast<size_t>(m_ip++)];

        try
        {
            // is there a registered opcode runner for the given opcode?
            if(!opcode_runners[ opc ].runner(this))
            {
                panic();
            }
        }
        catch (const primal::vm_panic&)
        {
            throw;
        }
        catch(...)
        {
            panic();
        }

        // is the opcode after the current one 0xFF meaning: halt the machine?
        if(m_ip < 0)
        {
            panic();
        }
        if(ms[static_cast<size_t>(m_ip)] == 0xFF)
        {
            bindump();
            return true;
        }
    }
    panic();
}

std::shared_ptr<vm> vm::create()
{
    // these functions are autogenerated by cmake in their own files
    register_opcodes();
    register_interrupts();

    return std::make_shared<vm>();
}

type_destination vm::fetch_type_dest()
{
    return static_cast<type_destination>(ms[static_cast<size_t>(m_ip ++)]) ;
}

void vm::bindump(numeric_t start, numeric_t end, bool insert_addr)
{
    if(start == -1) start = VM_MEM_SEGMENT_SIZE;
    if(end == -1) end = start + app_size;

    std::stringstream ss;
    std::string s;

    for(numeric_t i = start; i < std::min(end, VM_MEM_SEGMENT_SIZE + app_size); i++)
    {
        if(insert_addr)
        {
            ss << std::setfill(' ') << std::setw(9) << std::dec << std::right <<  i << "[:" << std::setw(3) << i - VM_MEM_SEGMENT_SIZE << "]";
            insert_addr = false;
        }
        if(i == m_ip)
        {
            ss << ">";
        }
        else
        {
            ss << " ";
        }
        ss << std::setfill('0') << std::setw(2) << std::hex << std::uppercase  << static_cast<int>(ms[static_cast<size_t>(i)]) ;

        if(ms[static_cast<size_t>(i)] > 32 && ms[static_cast<size_t>(i)] < 255)
        {
            s += static_cast<char>(ms[static_cast<size_t>(i)]);
        }
        else
        {
            s += '.';
        }

        if(i == m_ip)
        {
            ss << "<";
        }
        else
        {
            ss << " ";
        }
        if(ss.str().length() > 80)
        {
            std::cout << ss.str() << " | " << s << std::endl;
            s = "";
            ss.clear();
            ss.str(std::string());
            insert_addr = true;
        }
    }
    std::cout << ss.str() << std::endl;
    ss.clear();
    ss.str(std::string());

    // memory dump
    for(numeric_t i=0; i<stack_offset * num_t_size; i += num_t_size)
    {
        ss << std::right << " [" << std::setfill('0') << std::setw(8) << std::dec << i << "] = ";
        ss << get_mem(i) << std::endl;
    }
    ss << "-"; // indicates the stack start
    for(numeric_t i = stack_offset * num_t_size; i<max_used_sp + 32; i += num_t_size)
    {
        if(i == sp.value())
        {
            ss <<">" ; // current stack position
        }
        else
        {
            if (i > stack_offset * num_t_size) ss << " ";
        }

        ss << std::right << "[" << std::setfill('0') << std::setw(8) << std::dec << i << "] = ";
        ss << std::setfill('0') << std::setw(8) << std::dec << get_mem(i) << std::endl;
    }
    std::cout << ss.str();
}

void vm::panic()
{
    std::cout << "VM PANIC â˜¹ - instruction dump:\n---------------------------------------------------\n";
    numeric_t start = std::max(VM_MEM_SEGMENT_SIZE, m_ip - 64);
    numeric_t end = m_ip + std::min(64, app_size);
    bindump(start, end, true);
    std::cout << "IP=" << std::dec << m_ip << "[:" << m_ip - VM_MEM_SEGMENT_SIZE << "] (" << std::hex << m_ip << ")" << std::endl;
    std::cout << "SP=" << std::dec << sp.value() << " (" << std::hex << sp.value() << ")" << std::endl;
    std::cout << std::endl;
    throw primal::vm_panic("PANIC");
}

uint8_t vm::fetch_register_index()
{
    return ms[static_cast<size_t>(m_ip ++)];
}

numeric_t vm::fetch_immediate()
{
    numeric_t retv = htovm(*(reinterpret_cast<numeric_t*>(ms.get() + m_ip)));
    m_ip += num_t_size;
    return retv;
}

void vm::set_mem(numeric_t address, numeric_t new_value)
{
    if(address > VM_MEM_SEGMENT_SIZE || address < 0)
    {
        panic();
    }

    std::memcpy( &ms[0] + address, &new_value, sizeof(new_value));
}

numeric_t vm::get_mem(numeric_t address)
{
    if(address > VM_MEM_SEGMENT_SIZE || address < 0)
    {
        panic();
    }

    numeric_t v = 0;
    std::memcpy(&v, &ms[0] + address, sizeof(v));
    return v;
}

void vm::set_mem_byte(numeric_t address, uint8_t b)
{
    if(address > VM_MEM_SEGMENT_SIZE || address < 0)
    {
        panic();
    }
    ms[static_cast<size_t>(address)] = b;
}

uint8_t vm::get_mem_byte(numeric_t address)
{
    if(address > VM_MEM_SEGMENT_SIZE || address < 0)
    {
        panic();
    }
    return ms[static_cast<size_t>(address)];
}

reg_subbyte* vm::rsb(uint8_t ridx, uint8_t bidx)
{
    t1.m_r = &r(ridx);
    t1.m_bidx = bidx;
    return &t1;
}

memaddress* vm::mem(numeric_t address)
{
    auto setter = [&](numeric_t a, numeric_t v) -> void
        {
            set_mem(a,v);
        };
    auto getter = [&](numeric_t a) -> numeric_t
        {
            return get_mem(a);
        };

    ma_i = !ma_i;
    ma[ma_i].m_address = address;
    ma[ma_i].m_setter = setter;
    ma[ma_i].m_getter = getter;
    return &ma[ma_i];
}

memaddress_byte_ref* vm::mem_byte(numeric_t address)
{
    auto setter = [&](numeric_t a, uint8_t v) -> void
    {
        set_mem_byte(a,v);
    };
    auto getter = [&](numeric_t a) -> uint8_t
    {
        return get_mem_byte(a);
    };

    mb_i = !mb_i;
    mb[mb_i].m_address = address;
    mb[mb_i].m_setter = setter;
    mb[mb_i].m_getter = getter;
    return &mb[mb_i];
}


immediate *vm::imm(numeric_t v)
{
    mi_i++; if(mi_i == 3) mi_i = 1;

    imv[mi_i].m_value = v;
    return &imv[mi_i];
}

valued *vm::fetch()
{
    auto dst = fetch_type_dest();
    switch(dst)
    {
        case type_destination::TYPE_MOD_IMM:
        {
            return imm(fetch_immediate());
        }

        case type_destination::TYPE_MOD_REG_BYTE:
        {
            uint8_t ridx = fetch_register_index();
            return rsb(ridx, 0);
        }

        case type_destination::TYPE_MOD_REG_BYTE0:  // [[fallthrough]]
        case type_destination::TYPE_MOD_REG_BYTE1:
        case type_destination::TYPE_MOD_REG_BYTE2:
        case type_destination::TYPE_MOD_REG_BYTE3:
        {
            uint8_t ridx = fetch_register_index();
            return rsb(ridx, static_cast<uint8_t>(dst) - static_cast<uint8_t>(type_destination::TYPE_MOD_REG_BYTE0));
        }

            // are we moving something into a register?
        case type_destination::TYPE_MOD_REG:
        {
            uint8_t ridx = fetch_register_index();
            return &(r(ridx));
        }

            // are we moving something into an immediate memory address?
        case type_destination::TYPE_MOD_MEM_IMM:
        {
            numeric_t vaddr = fetch_immediate();
            return mem(vaddr);
        }

        case type_destination::TYPE_MOD_MEM_REG_IDX:
        {
            uint8_t ridx = fetch_register_index();
            return mem(r(ridx).value());
        }

        case type_destination::TYPE_MOD_MEM_REG_BYTE:
        {
            uint8_t ridx = fetch_register_index();
            return mem_byte(r(ridx).value());
        }

        case type_destination::TYPE_MOD_MEM_IMM_BYTE:
        {
            numeric_t vaddr = fetch_immediate();
            return mem_byte(vaddr);
        }

        case type_destination::TYPE_MOD_MEM_REG_IDX_OFFS:
        {
            uint8_t ridx = fetch_register_index();
            numeric_t vaddr = fetch_immediate();
            return mem(r(ridx).value() + vaddr);
        }
    }

    panic();

}

bool vm::call(numeric_t v)
{
    m_ip = VM_MEM_SEGMENT_SIZE + v;
    return m_ip < VM_MEM_SEGMENT_SIZE + app_size;
}

bool vm::interrupt(uint8_t i)
{
    std::function<bool(vm*)> fun;
    if(interrupts.count(i) > 0)
    {
        return interrupts[i].runner(this);
    }
    return false;
}

bool vm::address_is_valid(numeric_t addr)
{
    return addr < app_size + VM_MEM_SEGMENT_SIZE && addr >= 0;
}

bool vm::copy(numeric_t dest, numeric_t src, numeric_t cnt)
{
    if(dest + cnt > VM_MEM_SEGMENT_SIZE || src < 0 || dest < 0 || src > VM_MEM_SEGMENT_SIZE)
    {
        return false;
    }
    std::memmove(&ms[static_cast<size_t>(dest)], &ms[static_cast<size_t>(src)], static_cast<size_t>(cnt));
    return true;
}

bool vm::push(const valued* v)
{
    if(!v) return false;

    // value
    set_mem(sp.value(), v->value());
    sp += num_t_size;
    if(sp > max_used_sp) max_used_sp = sp.value();
    if(sp.value() > VM_MEM_SEGMENT_SIZE)
    {
        panic();
    }

    return true;
}

bool vm::push(const numeric_t v)
{
    immediate i(v);
    return push(&i);
}

numeric_t vm::pop()
{
    if(sp.value() - num_t_size < 0)
    {
        panic();
    }
    numeric_t v = get_mem(sp.value() - num_t_size);
    sp -= num_t_size;
    return v;
}
