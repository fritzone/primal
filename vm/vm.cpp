#include "vm.h"

#include <opcodes.h>
#include <hal.h>
#include <types.h>

#include <iostream>
#include <algorithm>
#include <memory>
#include <cstring>

std::map<uint8_t, vm::executor> vm::vm_runner;

vm::vm() : m_sp( m_r[255].value() ), m_dp( m_r[254].value() ), m_op( m_r[253].value() )
{
    for(uint8_t i = 0; i<255; i++)
    {
        m_r[i].set_idx(i);
    }
}


bool vm::run(const std::vector<uint8_t> &app)
{
    // firstly set up the memory segment for this machine and initialize it to 0xFF
    ms = std::make_unique<uint8_t[]>(app.size() + VM_MEM_SEGMENT_SIZE);
    std::fill(ms.get(), ms.get() + VM_MEM_SEGMENT_SIZE + app.size(), 0xFF);

    // then copy over the data from app to the end of the memory segment
    std::copy(app.begin(), app.end(), ms.get() + VM_MEM_SEGMENT_SIZE);

    // set the IP to point to the correct location
    m_ip = VM_MEM_SEGMENT_SIZE;

    // then start running it
    while(vm_runner.count(ms[m_ip]))
    {
        // read in an opcode
        uint8_t opc = ms[m_ip ++];

        // is there a registered opcode runner for the given opcode?
        if(!vm_runner[ opc ].opcode_runner(this))
        {
            panic();
            return false;
        }

        // is the opcode after the current one 0xFF meaning: halt the machine?
        if(ms[m_ip] == 0xFF)
        {
            return true;
        }
    }
    panic();
    return false;
}

std::shared_ptr<vm> vm::create()
{
    // this is autogenerated by cmake
    register_opcodes();

    return std::make_shared<vm>();
}

type_destination vm::fetch_type_dest()
{
    return static_cast<type_destination>(ms[m_ip ++]) ;
}

void vm::panic()
{
    std::cout << "PANIC!" << std::endl;
    exit(2);
}

uint8_t vm::fetch_register_index()
{
    return ms[m_ip ++];
}

numeric_t vm::fetch_immediate()
{
    numeric_t retv = htovm(*(reinterpret_cast<numeric_t*>(ms.get() + m_ip)));
    m_ip += sizeof(numeric_t);
    return retv;
}

void vm::set_mem(size_t address, numeric_t new_value)
{
    std::memcpy( &ms[0] + address, &new_value, sizeof(new_value));
}

numeric_t vm::get_mem(size_t address)
{
    numeric_t v = 0;
    std::memcpy(&v, &ms[0] + address, sizeof(v));
    return v;
}
