set(project vm)
string(TIMESTAMP now)

set(${project}-sources
    ${CMAKE_CURRENT_SOURCE_DIR}/vm.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/vm_impl.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/vm.h
    ${CMAKE_CURRENT_SOURCE_DIR}/vm_impl.h

    ${CMAKE_CURRENT_SOURCE_DIR}/loaded_function.h
    ${CMAKE_CURRENT_SOURCE_DIR}/loaded_function.cpp
)

set(registered_interrupts "")
set(registered_interrupt_files "")

#
# This funnction enables the specifed interrupt to be compiled into the application and also adds the file
# from the intr directory to the project
#
function(enable_interrupt nr)
    set(interrupt_file ${CMAKE_CURRENT_SOURCE_DIR}/intr/intr_${nr}.cpp)
    if(EXISTS "${interrupt_file}")
       set(registered_interrupts "${registered_interrupts};${nr}" PARENT_SCOPE)
       set(registered_interrupt_files "${registered_interrupt_files};${interrupt_file}" PARENT_SCOPE)
    else()
        message(FATAL_ERROR "Interrupt ${nr} was requeste however ${interrupt_file} is not to be found")
    endif()
endfunction()

#
# Register the interrupts
#

enable_interrupt(1)
enable_interrupt(2)


# Background works to enable interrupts
# Now create the "interupts.h"
set(INTRH "${CMAKE_CURRENT_BINARY_DIR}/interrupts.h")
file(WRITE ${INTRH} "// Autogenerated by CMake on ${now}. All modifications to this file will be lost\n")
file(APPEND ${INTRH} "#ifndef INTERRUPTS_H_INCLUDED\n")
file(APPEND ${INTRH} "#define INTERRUPTS_H_INCLUDED\n")
file(APPEND ${INTRH} "namespace primal {\n")
file(APPEND ${INTRH} "class vm;\n")
file(APPEND ${INTRH} "void register_interrupts();\n")

foreach(intr ${registered_interrupts})
    string(CONFIGURE "bool intr_${intr}(vm*);\n" conf_line @ONLY)
    file(APPEND ${INTRH} "" "${conf_line}")
endforeach()
file(APPEND ${INTRH} "}\n")

file(APPEND ${INTRH} "#endif\n")

# Now create interrupts.cpp
set(INTRCPP "${CMAKE_CURRENT_BINARY_DIR}/interrupts.cpp")
file(WRITE ${INTRCPP} "// Autogenerated by CMake on ${now}. All modifications to this file will be lost\n")
file(APPEND ${INTRCPP} "#include \"interrupts.h\"\n")
file(APPEND ${INTRCPP} "#include <vm_impl.h>\n\n")
file(APPEND ${INTRCPP} "namespace primal {\n")
file(APPEND ${INTRCPP} "void register_interrupts() {\n")
foreach(intr ${registered_interrupts})
    string(CONFIGURE "\tvm_impl::register_interrupt(${intr}, [&](primal::vm* v) -> bool { return primal::intr_${intr}(v); });" conf_line @ONLY)
    file(APPEND ${INTRCPP} "${conf_line}\n")
endforeach()
file(APPEND ${INTRCPP} "}\n}\n")

message(${registered_interrupt_files})
# Create the projects' library
add_library(${project} STATIC
        ${${project}-sources}
        ${registered_interrupt_files}
        ${INTRCPP}
)

# MODIFIED: Link vm library against the interface
target_link_libraries(${project} hal opcode-impl util interface)
target_include_directories(${project}
    PRIVATE
    ${CMAKE_CURRENT_BINARY_DIR}
    ${CMAKE_SOURCE_DIR}/interface/include
)

add_executable(primv ${CMAKE_CURRENT_SOURCE_DIR}/main.cpp)
target_link_libraries(primv ${project})
target_include_directories(primv
    PRIVATE
    ${CMAKE_SOURCE_DIR}/interface/include
)

install(TARGETS ${project}
    EXPORT primal-targets
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
)
install(FILES
    vm.h
    loaded_function.h
    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/primal
)
install(TARGETS primv DESTINATION ${CMAKE_INSTALL_BINDIR})
